"use strict";const t="KEYS",s="VALUES",r="";class e{constructor(t,s){const r=t.t,e=Array.from(r.keys());this.set=t,this.i=s,this.o=e.length>0?[{node:r,keys:e}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(0===this.o.length)return{done:!0,value:void 0};const{node:t,keys:s}=n(this.o);if(n(s)===r)return{done:!1,value:this.result()};const e=t.get(n(s));return this.o.push({node:e,keys:Array.from(e.keys())}),this.dive()}backtrack(){if(0===this.o.length)return;const t=n(this.o).keys;t.pop(),t.length>0||(this.o.pop(),this.backtrack())}key(){return this.set.h+this.o.map((({keys:t})=>n(t))).filter((t=>t!==r)).join("")}value(){return n(this.o).node.get(r)}result(){switch(this.i){case s:return this.value();case t:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const n=t=>t[t.length-1],i=(t,s,e,n,o,h,c,f)=>{const u=h*c;t:for(const a of t.keys())if(a===r){const s=o[u-1];s<=e&&n.set(f,[t.get(a),s])}else{let r=h;for(let t=0;t<a.length;++t,++r){const n=a[t],i=c*r,h=i-c;let f=o[i];const u=Math.max(0,r-e-1),l=Math.min(c-1,r+e);for(let t=u;t<l;++t){const r=n!==s[t],e=o[h+t]+ +r,c=o[h+t+1]+1,u=o[i+t]+1,a=o[i+t+1]=Math.min(e,c,u);a<f&&(f=a)}if(f>e)continue t}i(t.get(a),s,e,n,o,r,c,f+a)}};class o{constructor(t=new Map,s=""){this.u=void 0,this.t=t,this.h=s}atPrefix(t){if(!t.startsWith(this.h))throw new Error("Mismatched prefix");const[s,e]=h(this.t,t.slice(this.h.length));if(void 0===s){const[s,n]=d(e);for(const e of s.keys())if(e!==r&&e.startsWith(n)){const r=new Map;return r.set(e.slice(n.length),s.get(e)),new o(r,t)}}return new o(s,t)}clear(){this.u=void 0,this.t.clear()}delete(t){return this.u=void 0,u(this.t,t)}entries(){return new e(this,"ENTRIES")}forEach(t){for(const[s,r]of this)t(s,r,this)}fuzzyGet(t,s){return((t,s,r)=>{const e=new Map;if(void 0===s)return e;const n=s.length+1,o=n+r,h=new Uint8Array(o*n).fill(r+1);for(let t=0;t<n;++t)h[t]=t;for(let t=1;t<o;++t)h[t*n]=t;return i(t,s,r,e,h,1,n,""),e})(this.t,t,s)}get(t){const s=c(this.t,t);return void 0!==s?s.get(r):void 0}has(t){const s=c(this.t,t);return void 0!==s&&s.has(r)}keys(){return new e(this,t)}set(t,s){if("string"!=typeof t)throw new Error("key must be a string");this.u=void 0;return f(this.t,t).set(r,s),this}get size(){if(this.u)return this.u;this.u=0;const t=this.entries();for(;!t.next().done;)this.u+=1;return this.u}update(t,s){if("string"!=typeof t)throw new Error("key must be a string");this.u=void 0;const e=f(this.t,t);return e.set(r,s(e.get(r))),this}fetch(t,s){if("string"!=typeof t)throw new Error("key must be a string");this.u=void 0;const e=f(this.t,t);let n=e.get(r);return void 0===n&&e.set(r,n=s()),n}values(){return new e(this,s)}[Symbol.iterator](){return this.entries()}static from(t){const s=new o;for(const[r,e]of t)s.set(r,e);return s}static fromObject(t){return o.from(Object.entries(t))}}const h=(t,s,e=[])=>{if(0===s.length||null==t)return[t,e];for(const n of t.keys())if(n!==r&&s.startsWith(n))return e.push([t,n]),h(t.get(n),s.slice(n.length),e);return e.push([t,s]),h(void 0,"",e)},c=(t,s)=>{if(0===s.length||null==t)return t;for(const e of t.keys())if(e!==r&&s.startsWith(e))return c(t.get(e),s.slice(e.length))},f=(t,s)=>{const e=s.length;t:for(let n=0;t&&n<e;){for(const i of t.keys())if(i!==r&&s[n]===i[0]){const r=Math.min(e-n,i.length);let o=1;for(;o<r&&s[n+o]===i[o];)++o;const h=t.get(i);if(o===i.length)t=h;else{const r=new Map;r.set(i.slice(o),h),t.set(s.slice(n,n+o),r),t.delete(i),t=r}n+=o;continue t}const i=new Map;return t.set(s.slice(n),i),i}return t},u=(t,s)=>{const[e,n]=h(t,s);if(void 0!==e)if(e.delete(r),0===e.size)a(n);else if(1===e.size){const[t,s]=e.entries().next().value;l(n,t,s)}},a=t=>{if(0===t.length)return;const[s,e]=d(t);if(s.delete(e),0===s.size)a(t.slice(0,-1));else if(1===s.size){const[e,n]=s.entries().next().value;e!==r&&l(t.slice(0,-1),e,n)}},l=(t,s,r)=>{if(0===t.length)return;const[e,n]=d(t);e.set(n+s,r),e.delete(n)},d=t=>t[t.length-1];module.exports=o;
//# sourceMappingURL=SearchableMap.min.cjs.map
