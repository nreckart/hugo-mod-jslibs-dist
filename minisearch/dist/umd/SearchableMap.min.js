!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).MiniSearch=e()}(this,(function(){"use strict";const t="KEYS",e="VALUES",s="";class r{constructor(t,e){const s=t.t,r=Array.from(s.keys());this.set=t,this.i=e,this.o=r.length>0?[{node:s,keys:r}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(0===this.o.length)return{done:!0,value:void 0};const{node:t,keys:e}=n(this.o);if(n(e)===s)return{done:!1,value:this.result()};const r=t.get(n(e));return this.o.push({node:r,keys:Array.from(r.keys())}),this.dive()}backtrack(){if(0===this.o.length)return;const t=n(this.o).keys;t.pop(),t.length>0||(this.o.pop(),this.backtrack())}key(){return this.set.h+this.o.map((({keys:t})=>n(t))).filter((t=>t!==s)).join("")}value(){return n(this.o).node.get(s)}result(){switch(this.i){case e:return this.value();case t:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const n=t=>t[t.length-1],i=(t,e,r,n,o,h,f,c)=>{const u=h*f;t:for(const a of t.keys())if(a===s){const e=o[u-1];e<=r&&n.set(c,[t.get(a),e])}else{let s=h;for(let t=0;t<a.length;++t,++s){const n=a[t],i=f*s,h=i-f;let c=o[i];const u=Math.max(0,s-r-1),l=Math.min(f-1,s+r);for(let t=u;t<l;++t){const s=n!==e[t],r=o[h+t]+ +s,f=o[h+t+1]+1,u=o[i+t]+1,a=o[i+t+1]=Math.min(r,f,u);a<c&&(c=a)}if(c>r)continue t}i(t.get(a),e,r,n,o,s,f,c+a)}};class o{constructor(t=new Map,e=""){this.u=void 0,this.t=t,this.h=e}atPrefix(t){if(!t.startsWith(this.h))throw new Error("Mismatched prefix");const[e,r]=h(this.t,t.slice(this.h.length));if(void 0===e){const[e,n]=d(r);for(const r of e.keys())if(r!==s&&r.startsWith(n)){const s=new Map;return s.set(r.slice(n.length),e.get(r)),new o(s,t)}}return new o(e,t)}clear(){this.u=void 0,this.t.clear()}delete(t){return this.u=void 0,u(this.t,t)}entries(){return new r(this,"ENTRIES")}forEach(t){for(const[e,s]of this)t(e,s,this)}fuzzyGet(t,e){return((t,e,s)=>{const r=new Map;if(void 0===e)return r;const n=e.length+1,o=n+s,h=new Uint8Array(o*n).fill(s+1);for(let t=0;t<n;++t)h[t]=t;for(let t=1;t<o;++t)h[t*n]=t;return i(t,e,s,r,h,1,n,""),r})(this.t,t,e)}get(t){const e=f(this.t,t);return void 0!==e?e.get(s):void 0}has(t){const e=f(this.t,t);return void 0!==e&&e.has(s)}keys(){return new r(this,t)}set(t,e){if("string"!=typeof t)throw new Error("key must be a string");this.u=void 0;return c(this.t,t).set(s,e),this}get size(){if(this.u)return this.u;this.u=0;const t=this.entries();for(;!t.next().done;)this.u+=1;return this.u}update(t,e){if("string"!=typeof t)throw new Error("key must be a string");this.u=void 0;const r=c(this.t,t);return r.set(s,e(r.get(s))),this}fetch(t,e){if("string"!=typeof t)throw new Error("key must be a string");this.u=void 0;const r=c(this.t,t);let n=r.get(s);return void 0===n&&r.set(s,n=e()),n}values(){return new r(this,e)}[Symbol.iterator](){return this.entries()}static from(t){const e=new o;for(const[s,r]of t)e.set(s,r);return e}static fromObject(t){return o.from(Object.entries(t))}}const h=(t,e,r=[])=>{if(0===e.length||null==t)return[t,r];for(const n of t.keys())if(n!==s&&e.startsWith(n))return r.push([t,n]),h(t.get(n),e.slice(n.length),r);return r.push([t,e]),h(void 0,"",r)},f=(t,e)=>{if(0===e.length||null==t)return t;for(const r of t.keys())if(r!==s&&e.startsWith(r))return f(t.get(r),e.slice(r.length))},c=(t,e)=>{const r=e.length;t:for(let n=0;t&&n<r;){for(const i of t.keys())if(i!==s&&e[n]===i[0]){const s=Math.min(r-n,i.length);let o=1;for(;o<s&&e[n+o]===i[o];)++o;const h=t.get(i);if(o===i.length)t=h;else{const s=new Map;s.set(i.slice(o),h),t.set(e.slice(n,n+o),s),t.delete(i),t=s}n+=o;continue t}const i=new Map;return t.set(e.slice(n),i),i}return t},u=(t,e)=>{const[r,n]=h(t,e);if(void 0!==r)if(r.delete(s),0===r.size)a(n);else if(1===r.size){const[t,e]=r.entries().next().value;l(n,t,e)}},a=t=>{if(0===t.length)return;const[e,r]=d(t);if(e.delete(r),0===e.size)a(t.slice(0,-1));else if(1===e.size){const[r,n]=e.entries().next().value;r!==s&&l(t.slice(0,-1),r,n)}},l=(t,e,s)=>{if(0===t.length)return;const[r,n]=d(t);r.set(n+e,s),r.delete(n)},d=t=>t[t.length-1];return o}));
//# sourceMappingURL=SearchableMap.min.js.map
