const t="KEYS",r="VALUES",s="";class e{constructor(t,r){const s=t.t,e=Array.from(s.keys());this.set=t,this.i=r,this.o=e.length>0?[{node:s,keys:e}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(0===this.o.length)return{done:!0,value:void 0};const{node:t,keys:r}=n(this.o);if(n(r)===s)return{done:!1,value:this.result()};const e=t.get(n(r));return this.o.push({node:e,keys:Array.from(e.keys())}),this.dive()}backtrack(){if(0===this.o.length)return;const t=n(this.o).keys;t.pop(),t.length>0||(this.o.pop(),this.backtrack())}key(){return this.set.h+this.o.map((({keys:t})=>n(t))).filter((t=>t!==s)).join("")}value(){return n(this.o).node.get(s)}result(){switch(this.i){case r:return this.value();case t:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const n=t=>t[t.length-1],i=(t,r,e,n,o,h,c,f)=>{const u=h*c;t:for(const a of t.keys())if(a===s){const r=o[u-1];r<=e&&n.set(f,[t.get(a),r])}else{let s=h;for(let t=0;t<a.length;++t,++s){const n=a[t],i=c*s,h=i-c;let f=o[i];const u=Math.max(0,s-e-1),l=Math.min(c-1,s+e);for(let t=u;t<l;++t){const s=n!==r[t],e=o[h+t]+ +s,c=o[h+t+1]+1,u=o[i+t]+1,a=o[i+t+1]=Math.min(e,c,u);a<f&&(f=a)}if(f>e)continue t}i(t.get(a),r,e,n,o,s,c,f+a)}};class o{constructor(t=new Map,r=""){this.u=void 0,this.t=t,this.h=r}atPrefix(t){if(!t.startsWith(this.h))throw new Error("Mismatched prefix");const[r,e]=h(this.t,t.slice(this.h.length));if(void 0===r){const[r,n]=d(e);for(const e of r.keys())if(e!==s&&e.startsWith(n)){const s=new Map;return s.set(e.slice(n.length),r.get(e)),new o(s,t)}}return new o(r,t)}clear(){this.u=void 0,this.t.clear()}delete(t){return this.u=void 0,u(this.t,t)}entries(){return new e(this,"ENTRIES")}forEach(t){for(const[r,s]of this)t(r,s,this)}fuzzyGet(t,r){return((t,r,s)=>{const e=new Map;if(void 0===r)return e;const n=r.length+1,o=n+s,h=new Uint8Array(o*n).fill(s+1);for(let t=0;t<n;++t)h[t]=t;for(let t=1;t<o;++t)h[t*n]=t;return i(t,r,s,e,h,1,n,""),e})(this.t,t,r)}get(t){const r=c(this.t,t);return void 0!==r?r.get(s):void 0}has(t){const r=c(this.t,t);return void 0!==r&&r.has(s)}keys(){return new e(this,t)}set(t,r){if("string"!=typeof t)throw new Error("key must be a string");this.u=void 0;return f(this.t,t).set(s,r),this}get size(){if(this.u)return this.u;this.u=0;const t=this.entries();for(;!t.next().done;)this.u+=1;return this.u}update(t,r){if("string"!=typeof t)throw new Error("key must be a string");this.u=void 0;const e=f(this.t,t);return e.set(s,r(e.get(s))),this}fetch(t,r){if("string"!=typeof t)throw new Error("key must be a string");this.u=void 0;const e=f(this.t,t);let n=e.get(s);return void 0===n&&e.set(s,n=r()),n}values(){return new e(this,r)}[Symbol.iterator](){return this.entries()}static from(t){const r=new o;for(const[s,e]of t)r.set(s,e);return r}static fromObject(t){return o.from(Object.entries(t))}}const h=(t,r,e=[])=>{if(0===r.length||null==t)return[t,e];for(const n of t.keys())if(n!==s&&r.startsWith(n))return e.push([t,n]),h(t.get(n),r.slice(n.length),e);return e.push([t,r]),h(void 0,"",e)},c=(t,r)=>{if(0===r.length||null==t)return t;for(const e of t.keys())if(e!==s&&r.startsWith(e))return c(t.get(e),r.slice(e.length))},f=(t,r)=>{const e=r.length;t:for(let n=0;t&&n<e;){for(const i of t.keys())if(i!==s&&r[n]===i[0]){const s=Math.min(e-n,i.length);let o=1;for(;o<s&&r[n+o]===i[o];)++o;const h=t.get(i);if(o===i.length)t=h;else{const s=new Map;s.set(i.slice(o),h),t.set(r.slice(n,n+o),s),t.delete(i),t=s}n+=o;continue t}const i=new Map;return t.set(r.slice(n),i),i}return t},u=(t,r)=>{const[e,n]=h(t,r);if(void 0!==e)if(e.delete(s),0===e.size)a(n);else if(1===e.size){const[t,r]=e.entries().next().value;l(n,t,r)}},a=t=>{if(0===t.length)return;const[r,e]=d(t);if(r.delete(e),0===r.size)a(t.slice(0,-1));else if(1===r.size){const[e,n]=r.entries().next().value;e!==s&&l(t.slice(0,-1),e,n)}},l=(t,r,s)=>{if(0===t.length)return;const[e,n]=d(t);e.set(n+r,s),e.delete(n)},d=t=>t[t.length-1];export{o as default};
//# sourceMappingURL=SearchableMap.min.js.map
