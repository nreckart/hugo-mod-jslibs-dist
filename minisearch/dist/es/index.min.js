function t(t,e,i,s){return new(i||(i=Promise))((function(n,o){function r(t){try{h(s.next(t))}catch(t){o(t)}}function c(t){try{h(s.throw(t))}catch(t){o(t)}}function h(t){var e;t.done?n(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(r,c)}h((s=s.apply(t,e||[])).next())}))}"function"==typeof SuppressedError&&SuppressedError;const e="KEYS",i="VALUES",s="";class n{constructor(t,e){const i=t.t,s=Array.from(i.keys());this.set=t,this.i=e,this.o=s.length>0?[{node:i,keys:s}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(0===this.o.length)return{done:!0,value:void 0};const{node:t,keys:e}=o(this.o);if(o(e)===s)return{done:!1,value:this.result()};const i=t.get(o(e));return this.o.push({node:i,keys:Array.from(i.keys())}),this.dive()}backtrack(){if(0===this.o.length)return;const t=o(this.o).keys;t.pop(),t.length>0||(this.o.pop(),this.backtrack())}key(){return this.set.h+this.o.map((({keys:t})=>o(t))).filter((t=>t!==s)).join("")}value(){return o(this.o).node.get(s)}result(){switch(this.i){case i:return this.value();case e:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const o=t=>t[t.length-1],r=(t,e,i,n,o,c,h,u)=>{const f=c*h;t:for(const a of t.keys())if(a===s){const e=o[f-1];e<=i&&n.set(u,[t.get(a),e])}else{let s=c;for(let t=0;t<a.length;++t,++s){const n=a[t],r=h*s,c=r-h;let u=o[r];const f=Math.max(0,s-i-1),l=Math.min(h-1,s+i);for(let t=f;t<l;++t){const i=n!==e[t],s=o[c+t]+ +i,h=o[c+t+1]+1,f=o[r+t]+1,a=o[r+t+1]=Math.min(s,h,f);a<u&&(u=a)}if(u>i)continue t}r(t.get(a),e,i,n,o,s,h,u+a)}};class c{constructor(t=new Map,e=""){this.u=void 0,this.t=t,this.h=e}atPrefix(t){if(!t.startsWith(this.h))throw new Error("Mismatched prefix");const[e,i]=h(this.t,t.slice(this.h.length));if(void 0===e){const[e,n]=m(i);for(const i of e.keys())if(i!==s&&i.startsWith(n)){const s=new Map;return s.set(i.slice(n.length),e.get(i)),new c(s,t)}}return new c(e,t)}clear(){this.u=void 0,this.t.clear()}delete(t){return this.u=void 0,a(this.t,t)}entries(){return new n(this,"ENTRIES")}forEach(t){for(const[e,i]of this)t(e,i,this)}fuzzyGet(t,e){return((t,e,i)=>{const s=new Map;if(void 0===e)return s;const n=e.length+1,o=n+i,c=new Uint8Array(o*n).fill(i+1);for(let t=0;t<n;++t)c[t]=t;for(let t=1;t<o;++t)c[t*n]=t;return r(t,e,i,s,c,1,n,""),s})(this.t,t,e)}get(t){const e=u(this.t,t);return void 0!==e?e.get(s):void 0}has(t){const e=u(this.t,t);return void 0!==e&&e.has(s)}keys(){return new n(this,e)}set(t,e){if("string"!=typeof t)throw new Error("key must be a string");this.u=void 0;return f(this.t,t).set(s,e),this}get size(){if(this.u)return this.u;this.u=0;const t=this.entries();for(;!t.next().done;)this.u+=1;return this.u}update(t,e){if("string"!=typeof t)throw new Error("key must be a string");this.u=void 0;const i=f(this.t,t);return i.set(s,e(i.get(s))),this}fetch(t,e){if("string"!=typeof t)throw new Error("key must be a string");this.u=void 0;const i=f(this.t,t);let n=i.get(s);return void 0===n&&i.set(s,n=e()),n}values(){return new n(this,i)}[Symbol.iterator](){return this.entries()}static from(t){const e=new c;for(const[i,s]of t)e.set(i,s);return e}static fromObject(t){return c.from(Object.entries(t))}}const h=(t,e,i=[])=>{if(0===e.length||null==t)return[t,i];for(const n of t.keys())if(n!==s&&e.startsWith(n))return i.push([t,n]),h(t.get(n),e.slice(n.length),i);return i.push([t,e]),h(void 0,"",i)},u=(t,e)=>{if(0===e.length||null==t)return t;for(const i of t.keys())if(i!==s&&e.startsWith(i))return u(t.get(i),e.slice(i.length))},f=(t,e)=>{const i=e.length;t:for(let n=0;t&&n<i;){for(const o of t.keys())if(o!==s&&e[n]===o[0]){const s=Math.min(i-n,o.length);let r=1;for(;r<s&&e[n+r]===o[r];)++r;const c=t.get(o);if(r===o.length)t=c;else{const i=new Map;i.set(o.slice(r),c),t.set(e.slice(n,n+r),i),t.delete(o),t=i}n+=r;continue t}const o=new Map;return t.set(e.slice(n),o),o}return t},a=(t,e)=>{const[i,n]=h(t,e);if(void 0!==i)if(i.delete(s),0===i.size)l(n);else if(1===i.size){const[t,e]=i.entries().next().value;d(n,t,e)}},l=t=>{if(0===t.length)return;const[e,i]=m(t);if(e.delete(i),0===e.size)l(t.slice(0,-1));else if(1===e.size){const[i,n]=e.entries().next().value;i!==s&&d(t.slice(0,-1),i,n)}},d=(t,e,i)=>{if(0===t.length)return;const[s,n]=m(t);s.set(n+e,i),s.delete(n)},m=t=>t[t.length-1],w="or",p="and",b="and_not";class v{constructor(t){if(null==(null==t?void 0:t.fields))throw new Error('MiniSearch: option "fields" must be provided');const e=null==t.autoVacuum||!0===t.autoVacuum?k:t.autoVacuum;this.l=Object.assign(Object.assign(Object.assign({},j),t),{autoVacuum:e,searchOptions:Object.assign(Object.assign({},S),t.searchOptions||{}),autoSuggestOptions:Object.assign(Object.assign({},z),t.autoSuggestOptions||{})}),this.m=new c,this.p=0,this.v=new Map,this.O=new Map,this.M={},this.j=new Map,this.S=[],this.F=0,this.I=new Map,this.D=0,this.A=null,this.C=null,this.T=F,this.addFields(this.l.fields)}add(t){const{extractField:e,tokenize:i,processTerm:s,fields:n,idField:o}=this.l,r=e(t,o);if(null==r)throw new Error(`MiniSearch: document does not have ID field "${o}"`);if(this.O.has(r))throw new Error(`MiniSearch: duplicate ID ${r}`);const c=this.addDocumentId(r);this.saveStoredFields(c,t);for(const o of n){const n=e(t,o);if(null==n)continue;const r=i(n.toString(),o),h=this.M[o],u=new Set(r).size;this.addFieldLength(c,h,this.p-1,u);for(const t of r){const e=s(t,o);if(Array.isArray(e))for(const t of e)this.addTerm(h,c,t);else e&&this.addTerm(h,c,e)}}}addAll(t){for(const e of t)this.add(e)}addAllAsync(t,e={}){const{chunkSize:i=10}=e,s={chunk:[],promise:Promise.resolve()},{chunk:n,promise:o}=t.reduce((({chunk:t,promise:e},s,n)=>(t.push(s),(n+1)%i==0?{chunk:[],promise:e.then((()=>new Promise((t=>setTimeout(t,0))))).then((()=>this.addAll(t)))}:{chunk:t,promise:e})),s);return o.then((()=>this.addAll(n)))}remove(t){const{tokenize:e,processTerm:i,extractField:s,fields:n,idField:o}=this.l,r=s(t,o);if(null==r)throw new Error(`MiniSearch: document does not have ID field "${o}"`);const c=this.O.get(r);if(null==c)throw new Error(`MiniSearch: cannot remove document with ID ${r}: it is not in the index`);for(const o of n){const n=s(t,o);if(null==n)continue;const r=e(n.toString(),o),h=this.M[o],u=new Set(r).size;this.removeFieldLength(c,h,this.p,u);for(const t of r){const e=i(t,o);if(Array.isArray(e))for(const t of e)this.removeTerm(h,c,t);else e&&this.removeTerm(h,c,e)}}this.I.delete(c),this.v.delete(c),this.O.delete(r),this.j.delete(c),this.p-=1}removeAll(t){if(t)for(const e of t)this.remove(e);else{if(arguments.length>0)throw new Error("Expected documents to be present. Omit the argument to remove all documents.");this.m=new c,this.p=0,this.v=new Map,this.O=new Map,this.j=new Map,this.S=[],this.I=new Map,this.F=0}}discard(t){const e=this.O.get(t);if(null==e)throw new Error(`MiniSearch: cannot discard document with ID ${t}: it is not in the index`);this.O.delete(t),this.v.delete(e),this.I.delete(e),(this.j.get(e)||[]).forEach(((t,i)=>{this.removeFieldLength(e,i,this.p,t)})),this.j.delete(e),this.p-=1,this.D+=1,this.maybeAutoVacuum()}maybeAutoVacuum(){if(!1===this.l.autoVacuum)return;const{minDirtFactor:t,minDirtCount:e,batchSize:i,batchWait:s}=this.l.autoVacuum;this.conditionalVacuum({batchSize:i,batchWait:s},{minDirtCount:e,minDirtFactor:t})}discardAll(t){const e=this.l.autoVacuum;try{this.l.autoVacuum=!1;for(const e of t)this.discard(e)}finally{this.l.autoVacuum=e}this.maybeAutoVacuum()}replace(t){const{idField:e,extractField:i}=this.l,s=i(t,e);this.discard(s),this.add(t)}vacuum(t={}){return this.conditionalVacuum(t)}conditionalVacuum(t,e){return this.A?(this.T=this.T&&e,null!=this.C||(this.C=this.A.then((()=>{const e=this.T;return this.T=F,this.performVacuuming(t,e)}))),this.C):!1===this.vacuumConditionsMet(e)?Promise.resolve():(this.A=this.performVacuuming(t),this.A)}performVacuuming(e,i){return t(this,void 0,void 0,(function*(){const t=this.D;if(this.vacuumConditionsMet(i)){const i=e.batchSize||x.batchSize,s=e.batchWait||x.batchWait;let n=1;for(const[t,e]of this.m){for(const[t,i]of e)for(const[s]of i)this.v.has(s)||(i.size<=1?e.delete(t):i.delete(s));0===this.m.get(t).size&&this.m.delete(t),n%i==0&&(yield new Promise((t=>setTimeout(t,s)))),n+=1}this.D-=t}yield null,this.A=this.C,this.C=null}))}vacuumConditionsMet(t){if(null==t)return!0;let{minDirtCount:e,minDirtFactor:i}=t;return e=e||k.minDirtCount,i=i||k.minDirtFactor,this.dirtCount>=e&&this.dirtFactor>=i}get isVacuuming(){return null!=this.A}get dirtCount(){return this.D}get dirtFactor(){return this.D/(1+this.p+this.D)}has(t){return this.O.has(t)}getStoredFields(t){const e=this.O.get(t);if(null!=e)return this.I.get(e)}search(t,e={}){const i=this.executeQuery(t,e),s=[];for(const[t,{score:n,terms:o,match:r}]of i){const i=o.length||1,c={id:this.v.get(t),score:n*i,terms:Object.keys(r),queryTerms:o,match:r};Object.assign(c,this.I.get(t)),(null==e.filter||e.filter(c))&&s.push(c)}return t===v.wildcard&&null==e.boostDocument&&null==this.l.searchOptions.boostDocument||s.sort(D),s}autoSuggest(t,e={}){e=Object.assign(Object.assign({},this.l.autoSuggestOptions),e);const i=new Map;for(const{score:s,terms:n}of this.search(t,e)){const t=n.join(" "),e=i.get(t);null!=e?(e.score+=s,e.count+=1):i.set(t,{score:s,terms:n,count:1})}const s=[];for(const[t,{score:e,terms:n,count:o}]of i)s.push({suggestion:t,terms:n,score:e/o});return s.sort(D),s}get documentCount(){return this.p}get termCount(){return this.m.size}static loadJSON(t,e){if(null==e)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJS(JSON.parse(t),e)}static loadJSONAsync(e,i){return t(this,void 0,void 0,(function*(){if(null==i)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJSAsync(JSON.parse(e),i)}))}static getDefault(t){if(j.hasOwnProperty(t))return y(j,t);throw new Error(`MiniSearch: unknown option "${t}"`)}static loadJS(t,e){const{index:i,documentIds:s,fieldLength:n,storedFields:o,serializationVersion:r}=t,c=this.instantiateMiniSearch(t,e);c.v=C(s),c.j=C(n),c.I=C(o);for(const[t,e]of c.v)c.O.set(e,t);for(const[t,e]of i){const i=new Map;for(const t of Object.keys(e)){let s=e[t];1===r&&(s=s.ds),i.set(parseInt(t,10),C(s))}c.m.set(t,i)}return c}static loadJSAsync(e,i){return t(this,void 0,void 0,(function*(){const{index:t,documentIds:s,fieldLength:n,storedFields:o,serializationVersion:r}=e,c=this.instantiateMiniSearch(e,i);c.v=yield T(s),c.j=yield T(n),c.I=yield T(o);for(const[t,e]of c.v)c.O.set(e,t);let h=0;for(const[e,i]of t){const t=new Map;for(const e of Object.keys(i)){let s=i[e];1===r&&(s=s.ds),t.set(parseInt(e,10),yield T(s))}++h%1e3==0&&(yield V(0)),c.m.set(e,t)}return c}))}static instantiateMiniSearch(t,e){const{documentCount:i,nextId:s,fieldIds:n,averageFieldLength:o,dirtCount:r,serializationVersion:h}=t;if(1!==h&&2!==h)throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");const u=new v(e);return u.p=i,u.F=s,u.O=new Map,u.M=n,u.S=o,u.D=r||0,u.m=new c,u}executeQuery(t,e={}){if(t===v.wildcard)return this.executeWildcardQuery(e);if("string"!=typeof t){const i=Object.assign(Object.assign(Object.assign({},e),t),{queries:void 0}),s=t.queries.map((t=>this.executeQuery(t,i)));return this.combineResults(s,i.combineWith)}const{tokenize:i,processTerm:s,searchOptions:n}=this.l,o=Object.assign(Object.assign({tokenize:i,processTerm:s},n),e),{tokenize:r,processTerm:c}=o,h=r(t).flatMap((t=>c(t))).filter((t=>!!t)).map(g(o)).map((t=>this.executeQuerySpec(t,o)));return this.combineResults(h,o.combineWith)}executeQuerySpec(t,e){const i=Object.assign(Object.assign({},this.l.searchOptions),e),s=(i.fields||this.l.fields).reduce(((t,e)=>Object.assign(Object.assign({},t),{[e]:y(i.boost,e)||1})),{}),{boostDocument:n,weights:o,maxFuzzy:r,bm25:c}=i,{fuzzy:h,prefix:u}=Object.assign(Object.assign({},S.weights),o),f=this.m.get(t.term),a=this.termResults(t.term,t.term,1,t.termBoost,f,s,n,c);let l,d;if(t.prefix&&(l=this.m.atPrefix(t.term)),t.fuzzy){const e=!0===t.fuzzy?.2:t.fuzzy,i=e<1?Math.min(r,Math.round(t.term.length*e)):e;i&&(d=this.m.fuzzyGet(t.term,i))}if(l)for(const[e,i]of l){const o=e.length-t.term.length;if(!o)continue;null==d||d.delete(e);const r=u*e.length/(e.length+.3*o);this.termResults(t.term,e,r,t.termBoost,i,s,n,c,a)}if(d)for(const e of d.keys()){const[i,o]=d.get(e);if(!o)continue;const r=h*e.length/(e.length+o);this.termResults(t.term,e,r,t.termBoost,i,s,n,c,a)}return a}executeWildcardQuery(t){const e=new Map,i=Object.assign(Object.assign({},this.l.searchOptions),t);for(const[t,s]of this.v){const n=i.boostDocument?i.boostDocument(s,"",this.I.get(t)):1;e.set(t,{score:n,terms:[],match:{}})}return e}combineResults(t,e=w){if(0===t.length)return new Map;const i=e.toLowerCase(),s=O[i];if(!s)throw new Error(`Invalid combination operator: ${e}`);return t.reduce(s)||new Map}toJSON(){const t=[];for(const[e,i]of this.m){const s={};for(const[t,e]of i)s[t]=Object.fromEntries(e);t.push([e,s])}return{documentCount:this.p,nextId:this.F,documentIds:Object.fromEntries(this.v),fieldIds:this.M,fieldLength:Object.fromEntries(this.j),averageFieldLength:this.S,storedFields:Object.fromEntries(this.I),dirtCount:this.D,index:t,serializationVersion:2}}termResults(t,e,i,s,n,o,r,c,h=new Map){if(null==n)return h;for(const u of Object.keys(o)){const f=o[u],a=this.M[u],l=n.get(a);if(null==l)continue;let d=l.size;const m=this.S[a];for(const n of l.keys()){if(!this.v.has(n)){this.removeTerm(a,n,e),d-=1;continue}const o=r?r(this.v.get(n),e,this.I.get(n)):1;if(!o)continue;const w=l.get(n),p=this.j.get(n)[a],b=i*s*f*o*M(w,d,this.p,p,m,c),v=h.get(n);if(v){v.score+=b,E(v.terms,t);const i=y(v.match,e);i?i.push(u):v.match[e]=[u]}else h.set(n,{score:b,terms:[t],match:{[e]:[u]}})}}return h}addTerm(t,e,i){const s=this.m.fetch(i,A);let n=s.get(t);if(null==n)n=new Map,n.set(e,1),s.set(t,n);else{const t=n.get(e);n.set(e,(t||0)+1)}}removeTerm(t,e,i){if(!this.m.has(i))return void this.warnDocumentChanged(e,t,i);const s=this.m.fetch(i,A),n=s.get(t);null==n||null==n.get(e)?this.warnDocumentChanged(e,t,i):n.get(e)<=1?n.size<=1?s.delete(t):n.delete(e):n.set(e,n.get(e)-1),0===this.m.get(i).size&&this.m.delete(i)}warnDocumentChanged(t,e,i){for(const s of Object.keys(this.M))if(this.M[s]===e)return void this.l.logger("warn",`MiniSearch: document with ID ${this.v.get(t)} has changed before removal: term "${i}" was not present in field "${s}". Removing a document after it has changed can corrupt the index!`,"version_conflict")}addDocumentId(t){const e=this.F;return this.O.set(t,e),this.v.set(e,t),this.p+=1,this.F+=1,e}addFields(t){for(let e=0;e<t.length;e++)this.M[t[e]]=e}addFieldLength(t,e,i,s){let n=this.j.get(t);null==n&&this.j.set(t,n=[]),n[e]=s;const o=(this.S[e]||0)*i+s;this.S[e]=o/(i+1)}removeFieldLength(t,e,i,s){if(1===i)return void(this.S[e]=0);const n=this.S[e]*i-s;this.S[e]=n/(i-1)}saveStoredFields(t,e){const{storeFields:i,extractField:s}=this.l;if(null==i||0===i.length)return;let n=this.I.get(t);null==n&&this.I.set(t,n={});for(const t of i){const i=s(e,t);void 0!==i&&(n[t]=i)}}}v.wildcard=Symbol("*");const y=(t,e)=>Object.prototype.hasOwnProperty.call(t,e)?t[e]:void 0,O={[w]:(t,e)=>{for(const i of e.keys()){const s=t.get(i);if(null==s)t.set(i,e.get(i));else{const{score:t,terms:n,match:o}=e.get(i);s.score=s.score+t,s.match=Object.assign(s.match,o),I(s.terms,n)}}return t},[p]:(t,e)=>{const i=new Map;for(const s of e.keys()){const n=t.get(s);if(null==n)continue;const{score:o,terms:r,match:c}=e.get(s);I(n.terms,r),i.set(s,{score:n.score+o,terms:n.terms,match:Object.assign(n.match,c)})}return i},[b]:(t,e)=>{for(const i of e.keys())t.delete(i);return t}},M=(t,e,i,s,n,o)=>{const{k:r,b:c,d:h}=o;return Math.log(1+(i-e+.5)/(e+.5))*(h+t*(r+1)/(t+r*(1-c+c*s/n)))},g=t=>(e,i,s)=>({term:e,fuzzy:"function"==typeof t.fuzzy?t.fuzzy(e,i,s):t.fuzzy||!1,prefix:"function"==typeof t.prefix?t.prefix(e,i,s):!0===t.prefix,termBoost:"function"==typeof t.boostTerm?t.boostTerm(e,i,s):1}),j={idField:"id",extractField:(t,e)=>t[e],tokenize:t=>t.split($),processTerm:t=>t.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(t,e)=>{"function"==typeof(null===console||void 0===console?void 0:console[t])&&console[t](e)},autoVacuum:!0},S={combineWith:w,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:{k:1.2,b:.7,d:.5}},z={combineWith:"and",prefix:(t,e,i)=>e===i.length-1},x={batchSize:1e3,batchWait:10},F={minDirtFactor:.1,minDirtCount:20},k=Object.assign(Object.assign({},x),F),E=(t,e)=>{t.includes(e)||t.push(e)},I=(t,e)=>{for(const i of e)t.includes(i)||t.push(i)},D=({score:t},{score:e})=>e-t,A=()=>new Map,C=t=>{const e=new Map;for(const i of Object.keys(t))e.set(parseInt(i,10),t[i]);return e},T=e=>t(void 0,void 0,void 0,(function*(){const t=new Map;let i=0;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]),++i%1e3==0&&(yield V(0));return t})),V=t=>new Promise((e=>setTimeout(e,t))),$=/[\n\r\p{Z}\p{P}]+/u;export{v as default};
//# sourceMappingURL=index.min.js.map
